<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>系统架构 on Hugo Book</title><link>https://airdb.wiki/deancn/wiki/arch/</link><description>Recent content in 系统架构 on Hugo Book</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://airdb.wiki/deancn/wiki/arch/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://airdb.wiki/deancn/wiki/arch/ldc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://airdb.wiki/deancn/wiki/arch/ldc/</guid><description>浅谈双十一背后的支付宝LDC架构和其CAP分析
https://tbwork.org/2019/11/10/ant-ldc-arch/</description></item><item><title/><link>https://airdb.wiki/deancn/wiki/arch/question/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://airdb.wiki/deancn/wiki/arch/question/</guid><description>在新项目开发中如何？
在老项目维护中如何？
在技术构架演化中如何？</description></item><item><title>DDD - 领域驱动开发</title><link>https://airdb.wiki/deancn/wiki/arch/ddd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://airdb.wiki/deancn/wiki/arch/ddd/</guid><description>Domain-Drive Desgin # 实体 # 当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。 例：最简单的，公安系统的身份信息录入，对于人的模拟，即认为是实体，因为每个人是独一无二的，且其具有唯一标识（如公安系统分发的身份证号码）。 在实践上建议将属性的验证放到实体中。
值对象 # 当一个对象用于对事务进行描述而没有唯一标识时，它被称作值对象（Value Object）。 例：比如颜色信息，我们只需要知道{“name”:“黑色”，”css”:“#000000”}这样的值信息就能够满足要求了，这避免了我们对标识追踪带来的系统复杂性。 值对象很重要，在习惯了使用数据库的数据建模后，很容易将所有对象看作实体。使用值对象，可以更好地做系统优化、精简设计。 它具有不变性、相等性和可替换性。
在实践中，需要保证值对象创建后就不能被修改，即不允许外部再修改其属性。在不同上下文集成时，会出现模型概念的公用，如商品模型会存在于电商的各个上下文中。在订单上下文中如果你只关注下单时商品信息快照，那么将商品对象视为值对象是很好的选择。
聚合根 # Aggregate(聚合）是一组相关对象的集合，作为一个整体被外界访问，聚合根（Aggregate Root）是这个聚合的根节点。 聚合是一个非常重要的概念，核心领域往往都需要用聚合来表达。其次，聚合在技术上有非常高的价值，可以指导详细设计。
聚合由根实体，值对象和实体组成。
领域服务 # 一些重要的领域行为或操作，可以归类为领域服务。它既不是实体，也不是值对象的范畴。 当我们采用了微服务架构风格，一切领域逻辑的对外暴露均需要通过领域服务来进行。如原本由聚合根暴露的业务逻辑也需要依托于领域服务。
领域事件 # 领域事件是对领域内发生的活动进行的建模。
Reference:
The Clean Architecture 美团-领域驱动设计在互联网业务开发中的实践 浅析DDD(领域驱动设计) DDD 领域驱动设计 - 架构（分层/六边形/RESTful） 领域驱动设计（DDD）：分层架构的三种模式 Golang领域模型-六边形架构</description></item><item><title>六边形实践</title><link>https://airdb.wiki/deancn/wiki/arch/hexagonal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://airdb.wiki/deancn/wiki/arch/hexagonal/</guid><description>Golang领域模型-六边形架构
前言： 六边形架构又称“端口适配器架构”，实际上也是一种分层架构，只不过由上下或者左右变成了内部与外部。其核心理念就是应用通过端口与外部进行交互的。核心的业务逻辑（领域模型）与外部资源（数据库等资源）完全隔离，仅通过适配器进行交互，解决了业务逻辑与用户数据交错的问题，很好的实现了前后端分离。
分层架构问题： # 某些逻辑处理或某些数据处理该放在哪一层？ 该分多少层？ 平层和跨层调用是否合理? 项目目录 # domain - 领域模型 aggregate - 聚合 entity - 实体 dto - 传输对象 po - 持久化对象 *.go - 领域服务
adapter - 端口适配器 controller - 输入适配器 repository - 输出适配器
server - 服务端程序入口 conf - 配置文件 main.go - 主函数 infra - 基础设施 *go - 基础设施组件 domain 领域模型目录
对应六边形的内部，主要放领域服务service的代码。子目录分为aggregate聚合根目录、entity实体目录。 adapter 适配器目录
对应六边形的外部，主要是输入和输出的适配器。controller子目录负责 http的api输入，repository子目录负责实体的读写。dto子目录是controller或repository的外部输入输出对象。po子目录是数据库的持久化对象，这些对象是生成的。
The Clean Architecture Struct # internal/ ├── app │ ├── adapter │ │ ├── mysql │ │ │ ├── model │ │ │ │ └── user.</description></item></channel></rss>